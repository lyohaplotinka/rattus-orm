---
slug: v0.3.0
title: Версия 0.3.0
authors: [plotinka]
tags: [breaking-changes, progress]
---

Версия core-библиотеки достигла значения 0.3.0. Кратко расскажу, что нового в Rattus ORM.

#### TL;DR
* Процесс создания базы данных изменён: рекомендуемый путь - использовать функцию `createDatabase`;
* класс `Query` разделён на два - `Query` и `Constraintor`. Второй отвечает за применение ограничений к запросу данных, а `Query` наследуется от `Constrantor`. Это даст больше гибкости в случае поддержки асинхронных хранилищ;
* декораторы и методы атрибутов типов переименованы и вынесены в отдельный экспорт;
* добавлен декоратор `@DateField` (`this.dateField` в JS), для - очевидно - дат в ваших моделях;
* обновлены зависимости.


<!-- truncate -->

### createDatabase

Я всё тешу себя мыслями о поддержке асинхронных хранилищ. Очень хочется, чтобы это было сделано 
без "клонирования" core-пакета, и было легко в использовании. 

Абстракция для создания базы данных
вполне может этому поспособствовать, и, хоть в данном релизе и не появилась поддержка асинхронных
хранилищ, переделать процесс создания БД я решил уже сейчас. 

### Query и Constraintor

Сделано для тех же целей - надежда на поддержку асинхронных хранилищ в будущем. По ранним задумкам,
ограничения для выборки данных будут делаться одинаково для синхронных и асинхронных хранилищ.

### Новые имена и экспорт декораторов типов

Все методы, создающие атрибуты типов, а также декораторы для них, были переименованы: 
* `this.uid` => `this.uidField`; `@Uid` => `@UidField`;
* `this.string` => `this.stringField`; `@Str` => `@StringField`;
* `this.number` => `this.numberField`; `@Num` => `@NumberField`;
* `this.boolean` => `this.booleanField`; `@Bool` => `@BooleanField`;

Потеряна полная совместимость с Vuex ORM Next, но код станет чище, плюс меньше конфликтов с 
автокомплитом вашей IDE.

Кроме того, декораторы были вынесены из дефолтного экспорта в `@rattus-orm/core/decorators`. 
Это сделано для тех, кто использует Rattus ORM без TypeScript.

### DateField

В последние месяцы мне довелось немного поработать на бэкенде. Я использовал Nest JS и TypeORM, 
в качестве СУБД - Postgresql. В процессе работы с TypeORM я понял, чего нехватает Rattus ORM - 
типа `Date` для свойств ("колонок"). 

На фронтенде очень часто пользуются дополнительными решениями для работы с датами, вроде dayjs, date-fns
и так далее. Однако, если требуется простое взаимодействие, встроенной даты вполне достаточно. Поэтому
я решил избавить себя (и других пользователей) от необходимости каждый раз парсить дату вручную, 
отдав это на откуп атрибуту. 

По умолчанию тип не поддерживает `null` (как и все другие типы) - если передать null в класс модели
(или любое другое значение, которое приведёт к созданию Invalid date), 
Rattus ORM выдаст предупреждение в консоль, а в модели будет установлена "нулевая дата", та же, 
которая получается при вызове `new Date(0)`. Если явно разрешить полю принимать null - всё будет как обычно: 

```typescript
export class User extends Model {
    public static entity = 'user'

    @DateField(null, { nullable: true })
    public createdAt: Date | null
}
```

### Дальнейшие планы
Есть вероятность, что проект продолжит двигаться к большей совместимости с 
TypeORM, так как очень хочется позволить делить больше кода в проектах, 
где и фронтенд, и бэкенд написаны на TypeScript.
